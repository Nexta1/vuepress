---
sidebar: auto
---

# Mysql

## 使用

### 事务

1. 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
2. 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
3. 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，MVCC+隔离级别
4. 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失，WAL+Redo/Undo

WAL的全称为Write-Ahead Logging，先写日志，再写磁盘

> **在MySQL中，可以使用以下语句来定义和管理事务：**

* 开始事务：START TRANSACTION 或 BEGIN
* 提交事务：COMMIT
* 回滚事务：ROLLBACK
* 设置保存点：SAVEPOINT savepoint_name
* 回滚到保存点：ROLLBACK TO SAVEPOINT savepoint_name

```sql
START TRANSACTION;

-- 执行一系列数据库操作

-- 检查是否有错误或异常情况

IF <条件> THEN
ROLLBACK;
ELSE
COMMIT;
END IF;

# 保存点
START TRANSACTION;

-- 执行一系列数据库操作

SAVEPOINT savepoint_name;

-- 执行更多数据库操作

IF <条件> THEN
ROLLBACK TO SAVEPOINT savepoint_name;
ELSE
COMMIT;
END IF;

```

> **MySQL提供了四个隔离级别来控制并发事务的隔离程度，每个级别都具有不同的特点和权衡。以下是对每个隔离级别的详细介绍：**

1. 读未提交（Read Uncommitted）：
    - 最低的隔离级别，允许一个事务读取另一个事务未提交的数据。
    - 可能导致脏读（Dirty Read），即读取到未提交的数据，可能是无效或错误的数据。
    - 不提供任何并发控制，可能导致幻读（Phantom Read）和不可重复读（Non-repeatable Read）问题。

2. 读提交（Read Committed）：
    - 默认隔离级别，在每个SQL语句开始时获取一致性读取快照。
    - 保证了事务只能读取到已提交的数据，避免了脏读。
    - 但是，在同一个事务内，不同的查询可能返回不一致的结果，因为其他事务可能会修改已读取的数据。

3. 可重复读（Repeatable Read）：
    - 在事务开始时获取一致性读取快照，并在整个事务期间保持一致。
    - 保证了同一个事务内多次读取相同的数据将得到相同的结果即不可修改删除现有的数据，避免了不可重复读。
    - 但是，可能会遇到幻读问题，即在同一个事务内多次查询返回不同的行，针对插入而言。

4. 串行化（Serializable）：
    - 最高的隔离级别，确保了事务串行执行，避免了脏读、不可重复读和幻读问题。
    - 使用锁来保证事务的隔离，所有并发事务将按照顺序依次执行。
    - 可能导致并发性能下降，因为事务需要等待其他事务释放锁。

可以使用以下语句来设置MySQL中的隔离级别：

```
SET TRANSACTION ISOLATION LEVEL <隔离级别>;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

> 1. MVCC是什么？

MVCC（Multi-Version Concurrency Control）是一种并发控制机制，用于处理数据库系统中的并发读写操作，以保证数据的一致性和隔离性。
MVCC基于以下两个核心思想：

1. 版本号：每个事务在进行修改时，都会创建一个新的数据版本，并给该版本分配一个唯一的版本号。每个数据版本都包含了事务修改的数据值以及该版本的创建时间戳。
2. 读操作的快照：在进行读操作时，事务会根据自己的时间戳（通常是事务开始时的时间戳）获取一个一致性的数据库快照。该快照包含了在该时间戳之前已经提交的数据版本。
   :::tip
   读操作分为：快照读（select）和当前读（select... for update 或lock in share
   mode，insert/delete/update）也就是为什么前面的事务可以读到后面事务的更改。
   :::

MVCC的工作原理如下：

1. 数据版本管理：每个数据行都会维护多个版本，每个版本都有一个唯一的版本号和时间戳。当一个事务开始时，它会使用当前的系统时间戳作为自己的时间戳。
2. 读操作：当一个事务执行读操作时，它会根据自己的时间戳获取一个合适的数据库快照。该快照只包含在该时间戳之前已经提交的数据版本。这样可以确保读操作不会读取到未提交的数据或其他事务正在修改的数据。
3. 写操作：当一个事务执行写操作时，它会创建一个新的数据版本，并将新版本的数据写入数据库中。新版本会被赋予一个新的版本号，该版本号大于当前系统的时间戳。其他事务的读操作仍然可以读取到旧版本的数据。
4. 事务的提交和回滚：当一个事务提交时，它的修改将会成为新的数据版本，并且更新系统的时间戳为该事务的提交时间戳。如果一个事务被回滚，则丢弃该事务的所有修改，不会将其作为新的数据版本。
   通过使用MVCC，数据库系统能够提供高并发的读写操作，同时保证事务之间的隔离性和数据一致性。每个事务读取的数据是一致的，并且不会被其他事务的修改所影响，从而实现了更好的并发性能和数据完整性。

### 锁

> 类型

1. S锁（共享锁）只读 `select ... lock in share mode`
2. X锁（排他锁）阻断其他事务读写 `SELECT ... FOR UPDATE;`

> 性能

1. 乐观锁：提交更新报错。
   乐观锁是一种并发控制机制，与悲观锁不同，它假设并发操作之间不会产生冲突，而是在提交时检查是否有冲突并处理。以下是几种常见的实现乐观锁的方式：
    - 版本号（Versioning）：在数据表中添加一个版本号字段，每次更新数据时增加版本号。在进行更新操作时，先检查当前版本号是否与待更新数据的版本号匹配，如果匹配则执行更新，否则表示有其他事务修改了数据。
    - 时间戳（Timestamp）：为每条数据添加一个时间戳字段，记录数据的修改时间。在进行更新操作时，比较当前时间戳与待更新数据的时间戳，如果相等则执行更新，否则表示有其他事务修改了数据，需要处理冲突。
    - CAS（Compare and Set）：使用原子操作实现的比较和设置操作。在更新数据时，先比较当前数据与待更新数据是否一致，如果一致则执行更新操作，否则表示有其他事务修改了数据，需要处理冲突。
      具体实现乐观锁的方式取决于使用的数据库和编程语言。在MySQL中，可以使用版本号或者时间戳来实现乐观锁。在编程中，可以使用乐观锁相关的API或者自定义实现来实现乐观锁机制。
      需要注意的是，乐观锁适用于并发读取较多、冲突较少的场景，能够提高并发性能。但是如果冲突频繁发生，乐观锁会引发较多的冲突处理，可能导致性能下降。因此，在选择并发控制机制时，需要根据具体业务场景和需求来选择适当的锁机制。
2. 悲观锁：先锁定在更改

> 细粒度

1. 全局锁：只读状态
2. 表级锁：一种是表锁，一种是MDL（元数据锁）改变表结构DDL加MDL写锁,DQL/DML加读锁
3. 行级锁：锁的是索引,分为RecordLock、GapLock和Next-key Lock。
    - RecordLock：修改删除会阻止其他事务的操作
    - GapLock：范围查询会在索引间隙加锁，避免插入导致的幻读(for update)
    - Next-key Lock：它同时锁住记录和记录之前的间隙，以确保数据的完整性

> 在RR隔离级别，InnoDB对于记录加锁行为都是先采用Next-Key Lock，但是当SQL操作含有唯一索引时，Innodb会对Next-Key
> Lock进行优化，降级为RecordLock，仅锁住索引本身而非范围。

### 索引

以下是索引如何加快查询速度的几个关键点：

1. 减少数据的读取量：索引使得数据库系统可以快速定位到满足查询条件的数据行，而不需要逐行扫描整个表。通过直接访问索引，可以减少读取的数据量，从而提高查询的效率。
2. 提供数据的有序访问：索引通常是按照某种排序方式组织的，例如B-tree或哈希索引。这种有序的组织方式使得数据库系统可以更快地定位到满足查询条件的数据行，而无需遍历整个表。
3. 避免全表扫描：有了适当的索引，数据库系统可以使用索引的信息来快速过滤掉不符合查询条件的数据行，从而避免全表扫描。相比全表扫描，使用索引可以大大减少查询的时间复杂度。
4. 利用索引覆盖查询：当查询所需的列都包含在索引中时，数据库系统可以直接从索引中获取所需的数据，而无需再次访问数据行。这样可以避免额外的磁盘I/O操作，提高查询的速度。

需要注意的是，索引并非万能的，不适当或过多的索引可能会导致性能下降。索引会占用额外的存储空间，并在数据修改时增加维护成本。因此，在设计和使用索引时需要根据实际情况进行权衡和优化。
> 回表查询

聚簇索引的叶子节点存储行记录，InnoDB必须要有，且只有一个。辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记
录，通常情况下，需要扫码两遍索引树。先通过辅助索引定位主键值，然后再通过聚簇索引定位行记录，这就叫做回表查询，它的性能比扫一遍索引树低。
> 覆盖索引

如果查询字段只有索引就不需要回表查询
> 最左前缀原则

即查询中使用到最左边的列，那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效
> 无效索引

1. 函数或表达式
2. 类型转换
3. 不等于或不包含
4. 没有合适的组合索引

## 设计

### 设计范式

数据库表设计范式是一种规范和规则，用于确保数据库表的结构和关系模型的合理性、一致性和有效性。以下是常见的数据库表设计范式：

1. 第一范式（1NF）：确保每个数据库表的每个列都是原子的，不可再分的。每个列中的数据不能包含多个值或重复的值。

2. 第二范式（2NF）：在满足1NF的基础上，确保每个非主键列完全依赖于主键。如果表中存在复合主键，那么每个非主键列都应该与整个复合主键相关，而不是只与部分主键相关。

3. 第三范式（3NF）：在满足2NF的基础上，确保每个非主键列不依赖于其他非主键列。换句话说，每个非主键列应该只依赖于主键或其他唯一标识符。

4. 巴斯-科德范式（BCNF）：在满足3NF的基础上，确保每个非主键列不依赖于候选键的任何真子集。换句话说，不存在冗余的依赖关系。

5. 第四范式（4NF）：在满足BCNF的基础上，确保不存在非平凡的多值依赖关系。多值依赖是指在某个关系中，存在一组非主键列，它们共同决定其他非主键列的值。

6. 第五范式（5NF）：在满足4NF的基础上，确保不存在非平凡的联接依赖关系。联接依赖是指一个表中的某些列通过联接操作（JOIN）可以获取到另一个表中的某些列。

范式的级别越高，数据库表的设计越规范和优化，数据的冗余和异常依赖关系越少，表的结构越清晰和高效。然而，过度范式化也可能导致表之间的关系复杂化，查询的复杂性增加，因此在设计数据库时需要权衡范式和实际需求之间的平衡。

## 集群

### 数据备份

### 主从复制

MySQL主从复制是一种常用的数据库复制技术，它允许将一个MySQL数据库服务器（主服务器）上的数据自动地复制到一个或多个其他MySQL数据库服务器（从服务器）。这种复制方法常用于实现数据备份、读写分离和负载均衡等需求。

以下是MySQL主从复制的基本步骤：

1. 配置主服务器：在主服务器上，需要修改MySQL的配置文件（my.cnf或my.ini）来启用主从复制。添加以下配置参数：
   ```
   [mysqld]
   server-id = 1
   log-bin = mysql-bin
   binlog-do-db = your_database_name
   ```

   `server-id` 用于唯一标识主服务器，每个服务器都应该有不同的ID。`log-bin`
   启用二进制日志记录，记录主服务器上的所有数据更改操作。`binlog-do-db` 指定需要复制的数据库名。

2. 重启主服务器：重启MySQL服务以使配置生效。

3. 创建从服务器：在从服务器上，同样需要修改MySQL的配置文件来启用主从复制。添加以下配置参数：
   ```
   [mysqld]
   server-id = 2
   ```

   `server-id` 的值应该是与主服务器不同的唯一标识。

4. 重启从服务器：同样地，重启MySQL服务以使配置生效。

5. 配置主从关系：在主服务器上，创建一个专门用于从服务器复制的MySQL用户，并授予适当的权限。

6. 启动主从复制：在从服务器上执行以下命令来启动主从复制：
   ```
   CHANGE MASTER TO
   MASTER_HOST = 'ip_address_of_master',
   MASTER_USER = 'replication_user',
   MASTER_PASSWORD = 'replication_password',
   MASTER_PORT = master_mysql_port,  
   MASTER_LOG_FILE = 'mysql-bin.XXXXXX',
   MASTER_LOG_POS = log_position;
   ```

   替换 `'ip_address_of_master'` 为主服务器的IP地址，`'replication_user'` 和 `'replication_password'` 分别为在第 5
   步中创建的用于复制的MySQL用户的用户名和密码。`master_mysql_port` 是主服务器的MySQL端口号。`'mysql-bin.XXXXXX'`
   和 `log_position` 是在主服务器上执行 `SHOW MASTER STATUS;` 命令后得到的二进制日志文件名和位置。

7. 启动从服务器复制进程：在从服务器上执行 `START SLAVE;` 命令来启动从服务器复制进程。

现在，从服务器将开始连接到主服务器并复制主服务器上的数据。您可以通过在主服务器上进行数据更改来测试复制是否正常工作，从服务器上的相应数据库也会自动更新。

这只是MySQL主从复制的基本步骤，实际部署中可能需要根据具体情况进行额外的配置和调整。此外，为了确保复制的可靠性和一致性，还应该注意定期

备份数据、监控主从状态以及处理复制延迟等问题。

## 管理

MySQL的用户认证形式是: 用户名+主机。

```shell
mysql -u root -p123456
#查看权限和用户
SELECT User, Host FROM mysql.user;
SELECT user, host, authentication_string FROM mysql.user;

CREATE USER 'username'@'localhost' IDENTIFIED BY 'password';
DROP USER 'username'@'localhost';
```

### 权限分类

数据权限分为：库、表和字段三种级别
管理权限：主要是管理员要使用到的权限，包括：数据库创建，临时表创建、主从部署、进程管理等
程序权限：主要是触发器、存储过程、函数等权限。

```shell
SHOW GRANTS FOR 'root'@'localhost';
#mysql5.7
GRANT ALL PRIVILEGES ON *.* TO 'username'@'%' IDENTIFIED BY '123456';
#mysql8
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;

FLUSH PRIVILEGES;

REVOKE privileges ON database_name.table_name FROM 'username'@'localhost';
```

## 日志

MySQL 提供了多种类型的日志，用于记录数据库服务器的活动和错误信息。下面是几种常见的 MySQL 日志类型及其介绍：

1. 错误日志（Error Log）：
   错误日志记录了 MySQL 服务器在运行过程中发生的错误和警告信息，包括启动和关闭过程中的错误、查询执行错误、连接问题等。错误日志对于排查和解决数据库故障非常重要。
2. 查询日志（General Query Log）：
   查询日志记录了所有的客户端查询语句，包括 SELECT、INSERT、UPDATE、DELETE 等语句。查询日志可以用于分析和优化查询性能，但需要注意，启用查询日志会对数据库性能产生一定的影响。
3. 慢查询日志（Slow Query Log）：
   慢查询日志记录了执行时间超过预设阈值的查询语句，通常用来识别数据库中执行时间较长的查询语句。慢查询日志对于优化数据库性能非常有用，可以帮助开发人员找出需要优化的查询。
4. 二进制日志（Binary Log）：
   二进制日志记录了对数据库进行的所有更改操作，如插入、更新、删除等，以二进制格式保存。二进制日志可以用于数据复制、灾难恢复和故障恢复等操作。
5. 事务日志（Transaction Log）：
   事务日志（也称为重做日志或事务日志）记录了对数据库进行的事务操作，以确保数据的一致性和持久性。事务日志可以在数据库崩溃或断电后恢复数据的完整性。
6. 慢查询日志（Slow Query Log）：
   慢查询日志记录了执行时间超过预设阈值的查询语句，通常用来识别数据库中执行时间较长的查询语句。慢查询日志对于优化数据库性能非常有用，可以帮助开发人员找出需要优化的查询。
   这些日志可以通过 MySQL 配置文件中的相应参数进行启用或配置。每个日志类型都有其特定的用途，可以根据需求选择启用并分析相应的日志内容。

```shell
 show variables like '%general%'
```

```shell
log_error=/var/log/mysql/error.log
log_error_verbosity=3
#查询日志
general_log=ON
general_log_file=/var/log/mysql/general.log
#慢查询
slow_query_log=ON
slow_query_log_file=/var/log/mysql/slow.log
long_query_time=5
#二进制
log-bin=mysql-bin
binlog_stmt_cache_size = 1M
max_binlog_size = 128M
```

:::warning
如果配置文件不生效， `mysqladmin reload` 可以排查

`chmod -R 655 /docker/mysql8/conf/` 群组要有写的权限，否则无法写入配置不生效
:::

## mysqladmin

`mysqladmin` 是 MySQL 提供的一个管理工具，用于执行各种管理任务和操作。除了一些常见的管理任务外，`mysqladmin`
还提供了许多其他有用的选项和功能。以下是一些常用的 `mysqladmin` 命令：

1. `mysqladmin ping`：检查与 MySQL 服务器的连接是否正常。
2. `mysqladmin status`：显示 MySQL 服务器的当前状态，包括运行时间、连接数、线程信息等。
3. `mysqladmin processlist`：显示当前正在运行的 MySQL 进程列表。
4. `mysqladmin shutdown`：关闭 MySQL 服务器。
5. `mysqladmin create database_name`：创建一个新的数据库。
6. `mysqladmin drop database_name`：删除指定的数据库。
7. `mysqladmin reload`：重新加载 MySQL 配置文件，使新的配置生效。
8. `mysqladmin variables`：显示 MySQL 服务器的当前配置变量。
9. `mysqladmin extended-status`：显示 MySQL 服务器的详细状态信息，包括各种计数器和指标。
10. `mysqladmin flush-xxx`：执行不同类型的刷新操作，如 `flush-logs`、`flush-privileges`、`flush-tables` 等。
    这只是一些常见的 `mysqladmin` 命令示例，`mysqladmin` 支持许多其他选项和功能，你可以通过运行 `mysqladmin --help` 或参考
    MySQL 官方文档以获取更多详细信息和用法示例。

## 对比

MySQL 8与MySQL 5.7相比有以下几个区别和改进：

1. 认证方式：
   MySQL 8引入了更加安全的认证方式，默认使用了caching_sha2_password插件，取代了MySQL
   5.7中的mysql_native_password插件。caching_sha2_password支持更强的密码加密算法，提供更好的安全性。
2. JSON支持：
   MySQL 8在JSON数据类型上有了更多的支持。它引入了新的JSON函数和操作符，以便在JSON数据中进行更复杂的查询和操作。
3. 窗口函数：
   MySQL 8引入了窗口函数，这是一种强大的分析函数，可在查询结果集内执行计算和聚合操作。窗口函数允许在不使用GROUP
   BY子句的情况下对结果进行分组、排序和分析。
4. 增强的查询优化器：
   MySQL 8改进了查询优化器，使其更加智能和高效。它引入了更多的查询优化技术和算法，可以提高查询性能和执行效率。
5. 改进的索引：
   MySQL 8引入了更多的索引类型和改进，包括全文索引的改进和新增的空间索引类型。这些改进可以提高查询性能和灵活性。
6. 改进的并行查询：
   MySQL 8引入了并行查询执行功能，可以在多个CPU核心上同时执行查询，提高查询性能和响应时间。
7. 改进的故障恢复：
   MySQL 8引入了更好的故障恢复机制，包括原子性和一致性日志文件刷新等改进，以提高数据恢复的可靠性和效率。
   这些是MySQL 8相对于MySQL 5.7的一些主要区别和改进。根据具体的使用情况和需求，选择适合的MySQL版本可以获得更好的性能、功能和安全性。